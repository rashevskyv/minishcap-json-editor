### Парадигма: Від Редактора Файлів до Проектної "Робочої Станції"

Ми кардинально змінюємо підхід. Замість того, щоб думати про програму як про інструмент для редагування двох файлів (`original` та `edited`), ми перетворюємо її на **проектну робочу станцію**.

*   **Стара парадигма:** Програма — це "викрутка". Ви берете два файли, працюєте з ними, зберігаєте.
*   **Нова парадигма:** Програма — це "верстат". Ви створюєте **проект**, який є вашим робочим простором. Всередині цього простору ви можете мати багато "заготовок" (блоків/файлів), організовувати їх, ділити на частини (категорії) та обробляти як окремо, так і разом.

Це означає, що центральною сутністю стає **проект**, а не окремий файл. Проект інкапсулює в собі все: файли, налаштування плагіна, віртуальну структуру та метадані.

### Ключові Концепції

1.  **Проект (`Project`):** Фізична тека на комп'ютері. Містить у собі файл конфігурації `.uiproj` та підтеки для вихідних текстів (`sources/`) і перекладів (`translation/`). Це дозволяє легко переносити проект, ділитися ним та використовувати системи контролю версій (Git).

2.  **Блок (`Block`):** Пряме відображення пари файлів (`source` та `translation`). Це основна, фізична одиниця контенту. У дереві проекту це буде вузол верхнього рівня.

3.  **Категорія (`Category`):** Віртуальна, логічна група рядків **всередині одного блоку**. Це потужний фільтр. Категорії існують лише як метадані у файлі `.uiproj`. Вони не змінюють вихідні файли. Вони дозволяють:
    *   **Організовувати:** Згрупувати діалоги NPC, описи предметів, системні повідомлення, навіть якщо вони розкидані по всьому файлу.
    *   **Фокусуватися:** При виборі категорії ви бачите лише ті рядки, які до неї належать, з нумерацією від 1, що спрощує роботу з великими блоками.
    *   **Ізолювати роботу:** Застосовувати операції, як-от "AI Translate Block", лише до вибраної групи рядків, а не до всього файлу.

### Приклади Роботи (User Stories)

Давайте пройдемося по типовому сценарію роботи користувача з новою системою.

**Сценарій 1: Створення та наповнення проекту**

1.  Користувач запускає програму і бачить екран привітання. Він натискає **"Створити новий проект"**.
2.  З'являється діалог, де він вводить:
    *   Назва: `Переклад Wind Waker`
    *   Тека: `D:/Games/Translation/ZeldaWW`
    *   Плагін: `zelda_ww` (вибирає зі списку)
3.  Програма створює на диску теку `ZeldaWW`, а в ній — файл `project.uiproj` та порожні підтеки `sources` і `translation`. У вікні програми з'являється порожнє дерево з назвою проекту.
4.  Користувач правою кнопкою миші клікає на проекті -> **"Імпортувати блок..."**. Він вибирає файл `message_orig.txt`.
5.  Програма копіює `message_orig.txt` в `ZeldaWW/sources/`, створює порожній `message_orig.txt` в `ZeldaWW/translation/` і додає запис про цей блок у `project.uiproj`.
6.  У дереві з'являється новий елемент: `message_orig.txt`.

**Сценарій 2: Організація роботи за допомогою категорій**

1.  Користувач клікає на блок `message_orig.txt`. У вікні прев'ю відображаються тисячі рядків з цього файлу. Це незручно.
2.  Він вирішує створити категорію для діалогів на стартовому острові. Він клікає правою кнопкою на `message_orig.txt` в дереві -> **"Управління категоріями..."**.
3.  Відкривається діалог управління категоріями для цього блоку. Користувач створює нову категорію "Outset Island Dialogs" і додає опис: "Діалоги на стартовому острові до отримання меча".
4.  Тепер у дереві під `message_orig.txt` з'явилися дві підкатегорії: `Outset Island Dialogs` та `Uncategorized`.
5.  Користувач повертається до повного списку рядків (клікнувши на `message_orig.txt`). Він знаходить потрібні рядки:
    *   Клікає на рядок 15.
    *   Затискає `Shift` і клікає на рядок 45. Усі рядки з 15 по 45 виділяються.
    *   Затискає `Ctrl` і клікає на рядки 50 та 52. Вони також додаються до виділення.
6.  **Спосіб А (Drag-and-Drop):** Користувач затискає ліву кнопку миші на виділених рядках і перетягує їх на категорію `Outset Island Dialogs` у дереві.
7.  **Спосіб Б (Контекстне меню):** Користувач клікає правою кнопкою на виділених рядках -> **"Додати до категорії..."**. Відкривається діалог, де він вибирає `Outset Island Dialogs` і натискає "ОК".
8.  **Результат:** Тепер, коли користувач клікає на `Outset Island Dialogs`, у прев'ю він бачить лише рядки 15-45, 50, 52. Нумерація в прев'ю починається з 1. В рядку стану може бути написано `Рядок: 1 (файл: 15)`. При кліці на `Uncategorized` він бачить всі рядки, крім цих. При кліці на блок `message_orig.txt` баче всі рядки взагалі

**Сценарій 3: Контекстний переклад**

1.  Користувач вибрав категорію `Outset Island Dialogs`.
2.  Він натискає кнопку **"AI Translate Block"**.
3.  Програма збирає для перекладу **тільки** тексти рядків 15-45, 50, 52 з файлу `sources/message_orig.txt`. Решта файлу ігнорується.
4.  Після отримання результату, зміни записуються у відповідні рядки у файлі `translation/message_orig.txt`.

### Детальний План Реалізації

План реалізації системи проектів та віртуальних категорій

Мета: Трансформувати застосунок у проектну робочу станцію для перекладу, забезпечивши гнучке управління файлами-блоками та можливість їх віртуальної структуризації за допомогою ієрархічних категорій.

--- Етапи Реалізації ---

1.  **Закладення фундаменту: Моделі даних та управління проектами**
    *   **Обґрунтування:** Створення надійної структури даних у коді є першочерговим кроком. Це дозволить логічно представити проект, його фізичні блоки та віртуальні категорії, а також керувати їх збереженням та завантаженням.
    *   **Завдання:**
        1.  Розробити класи `Project`, `Block`, `Category` для представлення метаданих у пам'яті.
        2.  Створити `ProjectManager`, що інкапсулює логіку роботи з файлом `.uiproj`.
    *   **Файли та зміни:**
        *   **Новий файл `core/project_manager.py`**:
            *   `class Project`: зберігає назву, плагін, список об'єктів `Block`.
            *   `class Block`: зберігає ID, назву, шляхи, опис, та список кореневих `Category`.
            *   `class Category`: зберігає ID, назву, опис, список індексів рядків (`line_indices`), та список дочірніх `Category`.
            *   `class ProjectManager`: методи `load(path)`, `save()`, `add_block()`, `get_uncategorized_lines(block_id)`.

2.  **Перехід на проектний підхід: UI для управління проектами**
    *   **Обґрунтування:** Зміна основного робочого процесу з файло-орієнтованого на проектно-орієнтований.
    *   **Завдання:**
        1.  Реалізувати діалоги для створення/відкриття проектів.
        2.  Оновити меню "Файл" та відповідні хендлери.
    *   **Файли та зміни:**
        *   **Новий файл `components/project_dialogs.py`**.
        *   **Змінити `main.py` та `handlers/app_action_handler.py`**: Заміна `open_file_dialog_action` на `open_project_action`. Адаптація логіки завантаження та збереження для роботи з `ProjectManager`.

3.  **Візуалізація ієрархії: Дерево блоків та категорій з Drag-and-Drop**
    *   **Обґрунтування:** Необхідно надати користувачу інтуїтивний спосіб перегляду та маніпуляції ієрархічною структурою проекту. Drag-and-drop є ключовим елементом для зручного призначення рядків категоріям.
    *   **Завдання:**
        1.  Замінити `QListWidget` на `QTreeWidget` з підтримкою drag-and-drop.
        2.  Реалізувати логіку заповнення дерева, включаючи автоматичне створення вузла "Uncategorized".
    *   **Файли та зміни:**
        *   **Змінити `ui/ui_setup.py`**: Заміна `CustomListWidget` на `ProjectTreeView`.
        *   **Новий файл `components/project_tree_view.py`**: `class ProjectTreeView`, що реалізує `dragEnterEvent`, `dragMoveEvent`, `dropEvent`.
        *   **Новий файл `ui/updaters/project_tree_updater.py`**: `populate_tree`, що будує дерево з вузлом "Uncategorized".

4.  **Управління елементами: Універсальний діалог властивостей**
    *   **Обґрунтування:** Створення єдиного інтерфейсу для редагування властивостей як блоків, так і категорій (назва, опис).
    *   **Завдання:** Розробити діалогове вікно, що адаптується до типу вибраного елемента.
    *   **Файли та зміни:**
        *   **Новий файл `components/element_properties_dialog.py`**: `class ElementPropertiesDialog`.
        *   **Змінити `main.py`**: Підключити сигнал `itemDoubleClicked` від `ProjectTreeView`.

5.  **Взаємодія з рядками: Множинне виділення у прев'ю**
    *   **Обґрунтування:** Це основний механізм для вибору рядків, які будуть додані до категорії.
    *   **Завдання:**
        1.  Реалізувати виділення з Ctrl/Shift.
        2.  Ініціювати операцію drag-and-drop з виділених рядків.
    *   **Стан Реалізації:**
        *   **Зроблено:**
            *   Реалізовано інфраструктуру для зберігання списку виділених рядків (`_selected_lines` у `LineNumberedTextEdit`).
            *   Реалізовано ініціалізацію операції Drag-and-Drop з виділених рядків.
            *   Логіка обробки кліків з `Ctrl` та `Shift` для маніпуляції списком виділених рядків працює коректно (це було підтверджено логами).
            *   Оновлено контекстне меню для роботи зі списком виділених рядків (включаючи нерозривні діапазони).
        *   **Проблема:**
            *   **Візуальне відображення виділення не працює коректно.** Причина полягає у фундаментальному конфлікті між кастомною логікою виділення та вбудованою поведінкою віджета `QPlainTextEdit`. Стандартна поведінка віджета полягає в тому, щоб при кожному кліку скидати всі попередні виділення. Ця стандартна дія виконується раніше, ніж кастомна логіка встигає додати новий рядок до виділення, що призводить до того, що візуально виділеним залишається лише останній рядок, на який було здійснено клік.
    *   **План Вирішення:**
        1.  **Повна ізоляція обробки подій миші.** Щоб уникнути конфлікту, необхідно повністю перехопити та обробити події миші (`mousePressEvent` та `mouseReleaseEvent`) саме для віджета прев'ю, не даючи їм дійти до базової реалізації `QPlainTextEdit`.
        2.  **`LNET_mouse_handlers.py` - `mousePressEvent`:**
            *   Цей метод буде першим отримувати подію.
            *   Він вручну встановить позицію курсора (`setTextCursor`).
            *   Виконає всю логіку виділення з `Ctrl/Shift`, оновлюючи внутрішній список `_selected_lines`.
            *   Подія буде позначена як оброблена (`event.accept()`), щоб базовий віджет її не отримав і не скинув наше кастомне виділення.
        3.  **`LNET_mouse_handlers.py` - `mouseReleaseEvent`:**
            *   Аналогічно перехопить подію, щоб запобігти будь-яким небажаним діям з боку базового віджета при відпусканні кнопки миші.
        4.  **`TextHighlightManager.py` - `applyHighlights`:**
            *   Цей метод буде викликатися після кожної зміни у списку виділених рядків.
            *   Він застосує візуальне підсвічування до всіх рядків зі списку `_selected_lines`. Примусове оновлення (`viewport().update()`) забезпечить негайне відображення змін.
        *   **Результат:** Такий підхід гарантує, що наша логіка виділення є єдиною, яка виконується для віджета прев'ю, що забезпечить коректну та стабільну роботу як `Ctrl`, так і `Shift` виділень.
    *   **Файли та зміни:**
        *   **Змінити `components/LineNumberedTextEdit.py`, `components/TextHighlightManager.py`, `components/LNET_mouse_handlers.py`**: Додати логіку обробки кліків з модифікаторами, зберігання списку виділених індексів, візуалізації та ініціалізації `QDrag`.

6.  **Наповнення категорій: Діалог управління та контекстні меню**
    *   **Обґрунтування:** Надання користувачу гнучких інструментів для створення категорій та їх наповнення.
    *   **Завдання:**
        1.  Створити діалог для повного управління ієрархією категорій одного блоку.
        2.  Інтегрувати цей діалог у контекстні меню.
    *   **Файли та зміни:**
        *   **Новий файл `components/category_manager_dialog.py`**: `class CategoryManagerDialog` з деревом категорій та кнопками управління.
        *   **Змінити `components/LNET_mouse_handlers.py`**: Додати пункт "Додати до категорії..." у контекстне меню прев'ю.
        *   **Змінити `main.py`**: Додати контекстне меню до `ProjectTreeView` для прямого створення/редагування категорій.

7.  **Завершення циклу: Адаптація фільтрації та перекладу**
    *   **Обґрунтування:** Фінальний крок, який робить всю реалізовану структуру функціональною.
    *   **Завдання:** Зв'язати вибір у дереві з відображенням у прев'ю та логікою AI-перекладу.
    *   **Файли та зміни:**
        *   **Змінити `handlers/list_selection_handler.py`**: Перейменувати на `tree_selection_handler.py`. Метод `on_tree_item_selected` буде отримувати з `ProjectManager` список індексів для фільтрації.
        *   **Змінити `ui/updaters/preview_updater.py`**: `populate_strings_for_block` буде приймати опціональний список `line_indices`.
        *   **Змінити `handlers/translation_handler.py`**: `translate_current_block` буде отримувати список індексів для перекладу на основі поточного вибору в дереві.